

AWSTemplateFormatVersion: "2010-09-09"   
Description: "ECS Fargate cluster for my app _ VPC"

Parameters:
  EnvName:                               
    Type: String
    Default: dev
  


Resources:
  AppCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Sub "${EnvName}-cluster"


  AppVPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags:
        - Key: Name
          Value: !Sub "${EnvName}-vpc"

  
  AppInternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub "${EnvName}-igw"

  AppVPCGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref AppVPC
      InternetGatewayId: !Ref AppInternetGateway


  PublicSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref AppVPC
      CidrBlock: 10.0.1.0/24
      MapPublicIpOnLaunch: true
      AvailabilityZone: !Select [ 0, !GetAZs "" ]
      Tags:
        - Key: Name
          Value: !Sub "${EnvName}-public-subnet"


  PublicSubnetAZ2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref AppVPC
      CidrBlock: 10.0.3.0/24
      MapPublicIpOnLaunch: true
      AvailabilityZone: !Select [ 1, !GetAZs "" ]   # second AZ
      Tags:
        - Key: Name
          Value: !Sub "${EnvName}-public-subnet-az2"


  PrivateSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref AppVPC
      CidrBlock: 10.0.2.0/24
      MapPublicIpOnLaunch: false
      AvailabilityZone: !Select [ 0, !GetAZs "" ] 
      Tags:
        - Key: Name
          Value: !Sub "${EnvName}-private-subnet"


  PrivateSubnetAZ2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref AppVPC
      CidrBlock: 10.0.4.0/24
      MapPublicIpOnLaunch: false
      AvailabilityZone: !Select [ 1, !GetAZs "" ]
      Tags:
        - Key: Name
          Value: !Sub "${EnvName}-private-subnet-az2"

  ALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Sub "${EnvName}-alb-sg"
      VpcId: !Ref AppVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0    # allow HTTP from anywhere
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0    # allow HTTPS from anywhere
      SecurityGroupEgress:
        - IpProtocol: -1       # allow all outbound
          FromPort: 0
          ToPort: 0
          CidrIp: 0.0.0.0/0

  # 7) Security Group for Fargate tasks (containers)
  ContainerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Sub "${EnvName}-container-sg"
      VpcId: !Ref AppVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 3000
          ToPort: 3000
          SourceSecurityGroupId: !Ref ALBSecurityGroup  # only ALB on port 3000
      SecurityGroupEgress:
        - IpProtocol: -1       # containers can reach out anywhere (e.g. package repos)
          FromPort: 0
          ToPort: 0
          CidrIp: 0.0.0.0/0

  FrontendTaskDef:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Sub "${EnvName}-frontend-task"
      Cpu: "512"
      Memory: "1024"
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn: !GetAtt ECSTaskExecutionRole.Arn
      ContainerDefinitions:
        - Name: frontend
          Image: !Sub "${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/my-frontend:latest"
          PortMappings:
            - ContainerPort: 3000
          Essential: true
          Environment:
            - Name: REACT_APP_API_URL
              Value: "https://pd8768jjsc.execute-api.us-east-1.amazonaws.com/Prod/receive"
            - Name: NEXT_PUBLIC_SUPABASE_URL
              Value: "https://qkwviicbpbkkafstuxhx.supabase.co"
            - Name: NEXT_PUBLIC_SUPABASE_ANON_KEY
              Value: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFrd3ZpaWNkcGJra2Fmc3R1eHhoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDkxMzM4OTIsImV4cCI6MjA2NDcwOTg5Mn0.f6AvhycerXoCdCAhvpSOLW4N5_hoFsmnL_CcA8iri0s"
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref LogGroup
              awslogs-region: !Ref "AWS::Region"
              awslogs-stream-prefix: frontend



  ECSTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${EnvName}-ecs-exec-role"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy

  # CloudWatch Log Group for both frontend and backend logs
  LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/ecs/${EnvName}"
      RetentionInDays: 7

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref AppVPC
      Tags:
        - Key: Name
          Value: !Sub "${EnvName}-public-rt"


  PublicRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref AppInternetGateway

  
  PublicSubnetRouteTableAssoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet
      RouteTableId: !Ref PublicRouteTable

  PublicSubnetAZ2RouteTableAssoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetAZ2
      RouteTableId: !Ref PublicRouteTable



  AppLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub "${EnvName}-alb"
      Subnets:
        - !Ref PublicSubnet
        - !Ref PublicSubnetAZ2
      SecurityGroups:
        - !Ref ALBSecurityGroup
      Scheme: internet-facing
      Type: application

  # -- Frontend Target Group (port 3000)
  FrontendTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub "${EnvName}-frontend-tg"
      Port: 3000
      Protocol: HTTP
      VpcId: !Ref AppVPC
      TargetType: ip
      HealthCheckProtocol: HTTP
      HealthCheckPort: "3000"
      HealthCheckPath: "/"
      Matcher:
        HttpCode: "200"





  FrontendService:
    Type: AWS::ECS::Service
    DependsOn: 
      - HTTPListener
    Properties:
      ServiceName: !Sub "${EnvName}-frontend-svc"
      Cluster: !Ref AppCluster
      TaskDefinition: !Ref FrontendTaskDef
      DesiredCount: 1
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          Subnets:
            - !Ref PublicSubnet
            - !Ref PublicSubnetAZ2
          SecurityGroups:
            - !Ref ContainerSecurityGroup
          AssignPublicIp: ENABLED
      LoadBalancers:
        - ContainerName: frontend
          ContainerPort: 3000
          TargetGroupArn: !Ref FrontendTargetGroup




  HTTPListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn: AppLoadBalancer
    Properties:
      LoadBalancerArn: !Ref AppLoadBalancer
      Port: 80
      Protocol: HTTP
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref FrontendTargetGroup


  # ========================================
  # WEBSOCKET DASHBOARD COMPONENTS
  # ========================================
  
  # DynamoDB Tables
  WSConnectionsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: WSConnections
      AttributeDefinitions:
        - AttributeName: connectionId
          AttributeType: S
      KeySchema:
        - AttributeName: connectionId
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST

  InvoiceMetricsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: InvoiceMetrics
      AttributeDefinitions:
        - AttributeName: invoiceId
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: N
      KeySchema:
        - AttributeName: invoiceId
          KeyType: HASH
        - AttributeName: timestamp
          KeyType: RANGE
      BillingMode: PAY_PER_REQUEST

  # WebSocket API & Routes
  WebSocketApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: MetricsWS
      ProtocolType: WEBSOCKET
      RouteSelectionExpression: $request.body.action

  ConnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: $connect
      Target: !Sub "integrations/${ConnectIntegration}"

  DisconnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: $disconnect
      Target: !Sub "integrations/${DisconnectIntegration}"

  SubscribeRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: metrics-subscribe
      Target: !Sub "integrations/${SubscribeIntegration}"

  # WebSocket Integrations
  ConnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ConnectFunction.Arn}/invocations"

  DisconnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${DisconnectFunction.Arn}/invocations"

  SubscribeIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SubscribeFunction.Arn}/invocations"

  # WebSocket Deployment & Stage
  WebSocketDeployment:
    Type: AWS::ApiGatewayV2::Deployment
    Properties:
      ApiId: !Ref WebSocketApi
    DependsOn:
      - ConnectRoute
      - DisconnectRoute
      - SubscribeRoute

  WebSocketStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref WebSocketApi
      DeploymentId: !Ref WebSocketDeployment
      StageName: dev

  # Lambda Functions
  ConnectFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${EnvName}-ws-connect"
      Handler: src/ws/connect.handler
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          
          exports.handler = async (event) => {
            const connectionId = event.requestContext.connectionId;
            
            await dynamodb.put({
              TableName: process.env.WS_TABLE,
              Item: { connectionId, timestamp: Date.now() }
            }).promise();
            
            return { statusCode: 200 };
          };
      Runtime: nodejs18.x
      Role: !GetAtt LambdaExecutionRole.Arn
      Environment:
        Variables:
          WS_TABLE: !Ref WSConnectionsTable

  DisconnectFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${EnvName}-ws-disconnect"
      Handler: src/ws/disconnect.handler
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          
          exports.handler = async (event) => {
            const connectionId = event.requestContext.connectionId;
            
            await dynamodb.delete({
              TableName: process.env.WS_TABLE,
              Key: { connectionId }
            }).promise();
            
            return { statusCode: 200 };
          };
      Runtime: nodejs18.x
      Role: !GetAtt LambdaExecutionRole.Arn
      Environment:
        Variables:
          WS_TABLE: !Ref WSConnectionsTable

  SubscribeFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${EnvName}-ws-subscribe"
      Handler: src/ws/subscribe.handler
      Code:
        ZipFile: |
          exports.handler = async (event) => {
            // Acknowledge subscription
            return { statusCode: 200 };
          };
      Runtime: nodejs18.x
      Role: !GetAtt LambdaExecutionRole.Arn

  AggregatorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${EnvName}-metrics-aggregator"
      Handler: src/metrics/aggregator.handler
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          const apigateway = new AWS.ApiGatewayManagementApi({
            endpoint: process.env.WS_ENDPOINT
          });
          
          exports.handler = async (event) => {
            const now = Date.now();
            const sixtySecondsAgo = now - 60000;
            
            // Get metrics from last 60 seconds
            const metricsResult = await dynamodb.scan({
              TableName: process.env.METRICS_TABLE,
              FilterExpression: '#ts >= :start',
              ExpressionAttributeNames: { '#ts': 'timestamp' },
              ExpressionAttributeValues: { ':start': sixtySecondsAgo }
            }).promise();
            
            // Calculate aggregated metrics
            const metrics = metricsResult.Items || [];
            const total = metrics.length;
            const throughput = total / 60; // per second
            const avgLatency = metrics.reduce((sum, m) => sum + (m.latency || 0), 0) / (total || 1);
            const avgAccuracy = metrics.reduce((sum, m) => sum + (m.accuracy || 0), 0) / (total || 1);
            
            const payload = JSON.stringify({
              total,
              throughput: Math.round(throughput * 100) / 100,
              avgLatency: Math.round(avgLatency),
              avgAccuracy: Math.round(avgAccuracy * 100) / 100
            });
            
            // Get all WebSocket connections
            const connectionsResult = await dynamodb.scan({
              TableName: process.env.WS_TABLE
            }).promise();
            
            // Send to all connections
            const sendPromises = (connectionsResult.Items || []).map(async (connection) => {
              try {
                await apigateway.postToConnection({
                  ConnectionId: connection.connectionId,
                  Data: payload
                }).promise();
              } catch (error) {
                if (error.statusCode === 410) {
                  // Connection is stale, remove it
                  await dynamodb.delete({
                    TableName: process.env.WS_TABLE,
                    Key: { connectionId: connection.connectionId }
                  }).promise();
                }
              }
            });
            
            await Promise.all(sendPromises);
            return { statusCode: 200 };
          };
      Runtime: nodejs18.x
      Role: !GetAtt LambdaExecutionRole.Arn
      Environment:
        Variables:
          METRICS_TABLE: !Ref InvoiceMetricsTable
          WS_TABLE: !Ref WSConnectionsTable
          WS_ENDPOINT: !Sub "https://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/dev"

  # IAM Role for Lambda Functions
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:DeleteItem
                  - dynamodb:Scan
                  - dynamodb:Query
                Resource:
                  - !GetAtt WSConnectionsTable.Arn
                  - !GetAtt InvoiceMetricsTable.Arn
        - PolicyName: WebSocketAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - execute-api:ManageConnections
                Resource: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*"

  # Lambda Permissions for WebSocket API
  ConnectPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ConnectFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*"

  DisconnectPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref DisconnectFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*"

  SubscribePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref SubscribeFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*"

  # EventBridge Rule for Metrics Aggregation
  MetricsScheduler:
    Type: AWS::Events::Rule
    Properties:
      Description: "Trigger metrics aggregation every 30 seconds"
      ScheduleExpression: "rate(30 seconds)"
      State: ENABLED
      Targets:
        - Arn: !GetAtt AggregatorFunction.Arn
          Id: AggregatorTarget

  PermissionForEvents:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref AggregatorFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt MetricsScheduler.Arn

Outputs:
  ClusterName:
    Value: !Ref AppCluster
    Description: "Name of the ECS cluster"
  
  ApplicationURL:
    Value: !Sub "http://${AppLoadBalancer.DNSName}"
    Description: "AWS Load Balancer URL for testing"
    Export:
      Name: !Sub "${EnvName}-frontend-url"
  
  WebSocketEndpoint:
    Value: !Sub "wss://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/dev"
    Description: "WebSocket API endpoint for real-time metrics"
    Export:
      Name: !Sub "${EnvName}-websocket-url"


